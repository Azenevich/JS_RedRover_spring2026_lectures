# Объявление переменных, область видимости и практика на CodeWars

## Overview

Это занятие — ревью пройденного материала по JavaScript: объявление переменных (`let`, `const`, `var` и без ключевого слова), области видимости (scope), правила именования переменных, операторы сравнения (`==` vs `===`), конкатенация строк и чисел. Во второй части занятия разбирается работа с платформой CodeWars: как находить, решать и отправлять задачи. Решаются три задачи: на порядок операций (скобки), логический XOR и вычисление объёма параллелепипеда, вписанного в цилиндр.

## Prerequisites

- Понимание, что такое переменная и как присвоить ей значение с помощью `let` и `const`
- Знание базовых типов данных: числа (number), строки (string), логические значения (boolean)
- Умение использовать `console.log()` для вывода значений в консоль
- Знание арифметических операторов (`+`, `-`, `*`, `/`) и операторов сравнения (`>`, `<`, `>=`, `<=`, `==`, `===`, `!=`, `!==`)
- Знакомство с логическими операторами (`&&`, `||`, `!`)
- Базовое владение VS Code (запуск кода, комментирование строк через `Ctrl+/`)

## Key Concepts

### Блоки кода и область видимости (scope)

В JavaScript фигурные скобки `{}` создают отдельный **блок кода** — изолированный участок, внутри которого переменные, объявленные через `let` или `const`, видны только в пределах этого блока.

```js
{
  let lastname = "Smith";
  console.log(lastname); // "Smith" — работает, мы внутри блока
}
console.log(lastname); // Ошибка! lastname не существует за пределами блока
```

Если объявить переменную с тем же именем и внутри блока, и снаружи (обе через `let`), это будут **две разные переменные** в разных ячейках памяти:

```js
let lastname = "Doe";
{
  let lastname = "Smith"; // другая переменная, другая ячейка памяти
  console.log(lastname); // "Smith"
}
console.log(lastname); // "Doe"
```

*На практике создавать одноимённые переменные в разных блоках — плохой стиль, ухудшающий читабельность. Для подобных задач используются функции, которые будут рассмотрены позже.*

### Hoisting (поднятие переменных)

Перед выполнением кода JavaScript **сканирует** весь файл. Во время сканирования он находит все объявления переменных и «поднимает» их наверх (hoisting). При этом JavaScript не читает значения — он лишь резервирует ячейки в памяти.

```js
console.log(lastname); // Ошибка: переменная существует, но ещё не инициализирована
let lastname = "Doe";
```

JavaScript знает, что переменная `lastname` будет создана (он нашёл её при сканировании), но значение ей ещё не присвоено, потому что код выполняется сверху вниз.

Сканирование также позволяет JavaScript сразу находить **синтаксические ошибки** (например, незакрытые скобки) до начала выполнения кода.

### Объявление переменных: `let`, `const`, `var` и без ключевого слова

| Способ | Область видимости | Используем? |
|---|---|---|
| `let` | Блок кода `{}` | Да |
| `const` | Блок кода `{}` | Да |
| `var` | Вся функция (или весь файл, если вне функции) | Нет |
| без ключевого слова | Весь проект (все файлы) | Никогда |

**`let` и `const`** — единственные способы, которые следует использовать. Они ограничивают видимость переменной блоком кода, в котором она объявлена.

**`var`** — устаревший способ. Переменная, объявленная через `var`, видна во всём файле (или во всей функции), но не выходит за пределы файла. `var` не используется с 2015 года (ES6), но может встретиться в очень старом (legacy) коде.

**Без ключевого слова** — самый опасный вариант. Переменная становится **глобальной** и видна во всех файлах проекта. Это приводит к трудноотлавливаемым ошибкам: вы можете случайно перезаписать переменную из другого файла.

```js
// ПЛОХО — никогда так не делайте:
lastname = "Doe"; // глобальная переменная, видна везде

// ХОРОШО:
let lastname = "Doe"; // видна только в текущем блоке
```

*Если вы работаете с legacy-кодом, где переменные объявлены без ключевого слова, не убирайте `let`/`const` из своего нового кода. Вместо этого назовите свою переменную иначе:*

```js
// Старый код где-то объявил: lastname = "Old";
// Ваш новый код:
let myLastname = lastname; // скопировали значение
// Дальше работаем с myLastname
```

### Правила именования переменных

1. **Начинайте с буквы** — имя переменной не может начинаться с цифры (но может содержать цифры в середине или в конце).

```js
let 2hello = "hi"; // Ошибка! Нельзя начинать с цифры
let hello2 = "hi"; // OK
```

2. **Используйте camelCase** — если имя состоит из нескольких слов, каждое последующее слово начинается с заглавной буквы.

```js
let myFirstName = "John"; // camelCase — правильно
```

3. **Не используйте спецсимволы** — знак `$` и `_` технически допустимы, но на курсе не используются. Символ `#` имеет специальное значение в JavaScript и вызовет ошибку.

4. **Пишите на английском** — кириллица в именах переменных не используется. В значениях (строках) допустима, но лучше привыкать к английскому.

5. **Читабельность — главный принцип** — имя переменной должно мгновенно говорить, что в ней хранится.

### Оператор `==` vs `===`

- **`==` (двойное равно)** — сравнивает только **значения**. JavaScript пытается привести типы к одному (type coercion).
- **`===` (тройное равно)** — сравнивает **значение И тип данных**. Приведение типов не происходит.

```js
console.log(5 == "5");  // true — значения совпадают (строка "5" преобразуется в число 5)
console.log(5 === "5"); // false — типы разные (number vs string)
```

При использовании `==` JavaScript пытается преобразовать строку в число. Если преобразование удаётся — сравниваются числа. Если нет — результат `false`.

```js
console.log(5 == "hello"); // false — "hello" нельзя преобразовать в число
```

Сравнение с булевыми значениями: `true` преобразуется в `1`, `false` — в `0`.

```js
console.log(0 == false);  // true — false это 0
console.log(5 == true);   // false — true это 1, а не 5
```

При сравнении двух строк **регистр имеет значение**:

```js
console.log("hello" == "Hello"); // false — разный регистр
```

*Работа с регистром строк — частый источник ошибок. Методы для преобразования регистра рассматриваются на следующем занятии.*

### Конкатенация строк и чисел

Когда оператор `+` используется между числом и строкой, происходит **конкатенация** (склеивание), а не математическое сложение. Результат всегда будет строкой.

```js
let x = "hello";
let y = 5;
console.log(x + y); // "hello5" — строка, а не число
```

Порядок операций важен — JavaScript читает выражение **слева направо**:

```js
console.log(5 + 5 + "5"); // "105"
// Шаг 1: 5 + 5 = 10 (оба числа → математическое сложение)
// Шаг 2: 10 + "5" = "105" (число + строка → конкатенация)
```

### VS Code: регионы для сворачивания кода

Для организации кода в VS Code можно использовать **регионы** — именованные блоки, которые можно сворачивать и разворачивать:

```js
// #region My Section Name
let a = 1;
let b = 2;
console.log(a + b);
// #endregion

// #region Another Section
// ... код ...
// #endregion
```

Имя после `#region` необязательно, но помогает понять содержимое свёрнутого блока.

## Code Examples

### Задача 1: Порядок операций (CodeWars)

**Условие:** выражение `2 + 2 * 2 + 2 * 2` возвращает 10, а ожидается 32. Нужно расставить скобки, не меняя цифры и операторы.

```js
// Решение: группируем сложения в скобки, чтобы они выполнились раньше умножения
function expression() {
  return (2 + 2) * (2 + 2) * 2; // (4) * (4) * 2 = 32
}
```

### Задача 2: Логический XOR (CodeWars)

**Условие:** реализовать функцию исключающего ИЛИ (XOR). XOR возвращает `true`, если значения **различаются**, и `false`, если они **одинаковы**.

| a | b | XOR |
|---|---|---|
| false | false | false |
| true | false | true |
| false | true | true |
| true | true | false |

```js
function xor(a, b) {
  return a !== b; // если a и b различаются — true, если совпадают — false
}
```

*Существуют и другие решения, например `(a || b) && !(a && b)`, но `a !== b` — самое простое и читаемое.*

### Задача 3: Объём параллелепипеда в бутылке (CodeWars)

**Условие:** в цилиндрическую бутылку помещают прямоугольный блок льда. Длина и ширина блока равны (квадрат в сечении). Блок касается стенок бутылки. Дано: радиус бутылки (`radius`), длина бутылки (`bottleLength`), длина горлышка (`rimLength`). Найти объём блока.

**Ключевая формула:** площадь квадрата, вписанного в окружность радиуса `r`, равна `2 * r²` (выводится из теоремы Пифагора: диагональ квадрата = диаметр окружности = `2r`, сторона² + сторона² = (2r)², значит 2 * сторона² = 4r², сторона² = 2r², а площадь = сторона² = 2r²).

```js
function iceBrickVolume(radius, bottleLength, rimLength) {
  let height = bottleLength - rimLength; // высота блока
  let volume = 2 * radius * radius * height; // площадь сечения × высота
  return volume;
}
```

## Common Mistakes & Pitfalls

- **Объявление переменной без `let`/`const`** — создаёт глобальную переменную, видимую во всех файлах проекта. Может незаметно перезаписать чужую переменную и привести к ошибкам, которые крайне сложно найти. Всегда используйте `let` или `const`.

- **Имя переменной начинается с цифры** — JavaScript не позволяет этого. Цифры можно использовать в середине или конце имени: `hello2` — допустимо, `2hello` — ошибка.

- **Путаница между `==` и `===`** — `==` сравнивает только значения (с приведением типов), `===` сравнивает и значение, и тип. Например, `5 == "5"` это `true`, но `5 === "5"` это `false`.

- **Неожиданная конкатенация вместо сложения** — при `+` между числом и строкой JavaScript склеивает их в строку: `5 + "5"` даёт `"55"`, а не `10`. Порядок чтения слева направо влияет на результат: `5 + 5 + "5"` даёт `"105"`.

- **Забывают про регистр при сравнении строк** — `"hello" === "Hello"` это `false`. При сравнении строк регистр всегда учитывается.

- **Использование `Ctrl+/` для вложенного комментирования** — `Ctrl+/` переключает комментарий для всей строки. Если нужен комментарий внутри строки рядом с кодом, напишите `//` вручную, а затем применяйте `Ctrl+/` поверх.

## Key Takeaways

1. Всегда объявляйте переменные через `let` (если значение будет меняться) или `const` (если не будет) — никогда через `var` или без ключевого слова.
2. `let` и `const` ограничивают видимость переменной блоком кода `{}`, в котором она объявлена, что защищает от конфликтов имён.
3. JavaScript сканирует код перед выполнением (hoisting), но не знает значений переменных до момента их инициализации.
4. Оператор `===` безопаснее `==`, потому что не выполняет неявное приведение типов.
5. Оператор `+` между строкой и числом выполняет конкатенацию (склеивание), а не сложение — порядок операндов слева направо определяет результат.
6. При решении задач на CodeWars: сначала нажимайте **Test** (быстрая проверка), затем **Attempt** (расширенная проверка), и только потом **Submit** (отправка решения).
7. Если вам не хватает знаний для решения задачи (например, математической формулы), используйте поиск в Google — это нормальная и важная часть работы программиста.

## Glossary

| Term | Definition |
|---|---|
| Scope (область видимости) | Часть кода, в которой переменная доступна для чтения и записи. У `let`/`const` — блок `{}`, у `var` — функция или файл, без ключевого слова — весь проект. |
| Hoisting (поднятие) | Механизм JavaScript, при котором объявления переменных автоматически «поднимаются» к началу их области видимости на этапе сканирования кода (до выполнения). |
| Block (блок кода) | Участок кода, заключённый в фигурные скобки `{}`. Переменные `let`/`const` внутри блока недоступны снаружи. |
| Type coercion (приведение типов) | Автоматическое преобразование одного типа данных в другой при сравнении или операции. Например, `"5"` преобразуется в `5` при использовании `==`. |
| Concatenation (конкатенация) | Склеивание строк (или строки и числа) оператором `+`. Результат — всегда строка. |
| XOR (исключающее ИЛИ) | Логическая операция, возвращающая `true`, если ровно одно из двух значений истинно, и `false` в остальных случаях. |
| Legacy code | Старый код, написанный с использованием устаревших практик (например, `var` или объявление переменных без ключевого слова). |
| Region (регион) | Комментарий-маркер в VS Code (`// #region` ... `// #endregion`), позволяющий сворачивать и разворачивать участки кода для удобства навигации. |
